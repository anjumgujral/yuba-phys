---
title: "06_PLC"
author: "Anjum K. Gujral"
date: '2024-08-25'
output: html_document
---
# load packages
```{r}
install.packages('janitor')
library(janitor)
install.packages('here')
library(here)
install.packages('lubridate')
library(lubridate)
install.packages('readxl')
library(readxl)
library(gridExtra)
library(MetBrewer)
library(dlookr)
install.packages('beeswarm')
library(beeswarm)
library(tidyverse)
geom_beeswarm = ggbeeswarm::geom_beeswarm()
here = here::here()
library(scales)
library(gridExtra)
library(ggrepel)
library(boot)
library(devtools)
library(fitplc)
library(dplyr)

```

# load 2024 raw data
```{r}
DATADIR = "/Users/anjumgujral/Box Sync/yuba-phys_data/P50"

cavitron_files <- list.files(path = here::here("P50", "P50_individual"), pattern = "*.csv", full.names = TRUE, include.dirs = T, recursive = T) 

# Read and combine CSV files
all_cavitron_data<- cavitron_files %>%
  map_dfr(~read_csv(.x, skip = 1, col_names = read_csv(.x, n_max = 1)))


# Assuming you have a combined dataframe called combined_data

# Initialize an empty list to store individual dataframes
dataframes <- list()

# Initialize a variable to keep track of the current header
current_header <- NULL

some_condition <- function(row) {
  # Check if the first cell in the row contains "Date_time" (case insensitive)
  first_cell <- as.character(row[1])
  return(grepl("Date_time", first_cell, ignore.case = TRUE))
}

# Loop through rows in combined_data
for (i in 1:nrow(all_cavitron_data)) {
  # Check if the current row could be a header (you can customize this condition)
  if (some_condition(all_cavitron_data[i, ])) {
    # Set the current row as the column names
    current_header <- as.character(all_cavitron_data[i, ])
  } else {
    # If it's not a header, create a new dataframe and add it to the list
    if (!is.null(current_header)) {
      dataframes <- append(dataframes, list(
        setNames(all_cavitron_data[i, , drop = FALSE], current_header)
      ))
    }
  }
}

# Combine all the individual dataframes into one
cavitron_df <- do.call(rbind, dataframes) %>% 
  janitor::clean_names() 

vc_all <- cavitron_df %>% 
  janitor::clean_names() %>% 
  drop_na(campaign_name) %>% 
  dplyr::mutate( 
         tree = as.numeric(sample_ref_1), 
         #branch = sample_ref_2,
         mpa = as.numeric(pressure_mpa) * -1,
         pressures = mpa,
         neg_mpa = as.numeric(pressure_mpa),
        k = as.numeric(raw_conductance_kg_mpa_s),           #raw stem hydraulic conductance
        kstem_length = as.numeric(conductivity_si_corr_t),  #hydraulic conductivity per stem length 
        #stem_id = paste(site, tree, branch, sep = "-"),
        plc_new = as.numeric(plc),
        #species = case_when(
    #species %in% c("Abies concolor") ~ "ABCO", 
    #species %in% c("Pinus lambertiana") ~ "PILA", 
    #species %in% c("Calocedrus decurrens") ~ "CADE", 
    #TRUE ~ as.character(species)), 
    type = case_when(speed_class %in% c("a") ~ "kmax", #maximum conductivity point (from speed class "a")
                     speed_class %in% c("b", "c","d", "e", "f", "g", "h", "i") ~ "VC", 
      TRUE ~ as.character(speed_class))) %>%  # everything else = speed classes "b" to "i")
  select(tree, mpa, neg_mpa, k, kstem_length, plc_new, type) %>% 
  mutate(size = as.factor("B"), 
         plc_new = case_when(  #set bounds for PLC new from 0-100
           plc_new < 0 ~ 0, 
           plc_new > 100 ~ 100,
           TRUE ~ as.numeric(plc_new)
         )) %>% 
  drop_na(plc_new)

vc_all2 <- vc_all %>% 
  group_by(tree) %>% 
  mutate(group = case_when(
    mpa == min(mpa) ~ "a",              #if mpa is the minimum mpa for that tree, assign group "a" (kmax)
    TRUE ~ as.character("b"))) %>%      #otherwise assign it to group "b"
  group_by(tree) %>% 
  mutate(mean_kstem_a = mean(kstem_length[group == 'a'], na.rm = T)) %>%  # mean of the kmax values
  ungroup() %>% 
  mutate(plc_new = 100-(100*kstem_length/mean_kstem_a))%>%   #calculate PLC from 
  drop_na(plc_new)

#save all raw vulnerability curve data
# note: there are duplicates in here, come back to clean later
write.csv(vc_all2, file = "yuba-phys-vulnerability-curve-raw-data-2024.csv", row.names = FALSE)

```

# load 2025 raw data
```{r}

cavitron_files_2025 <- c(
  here::here("P50", "p50_8_28_2025.csv"),
  here::here("P50", "p50_9_15_2025.csv")
)

# Read both CSVs, skip first line (metadata), use second line as header, combine
cavitron_2025_df <- cavitron_files_2025 %>%
  map_dfr(~ read_csv(.x, skip = 1, col_names = TRUE)) %>%
  janitor::clean_names()

# Now run your data cleaning and transformation pipeline
vc_all_2025 <- cavitron_2025_df %>%
  filter(!is.na(sample_ref_1)) %>%    # Keep only rows with tree IDs
  mutate(tree = as.numeric(sample_ref_1),
         mpa = as.numeric(pressure_mpa) * -1,
         pressures = mpa,
         neg_mpa = as.numeric(pressure_mpa),
         k = as.numeric(raw_conductance_kg_mpa_s),           #raw stem hydraulic conductance
         kstem_length = as.numeric(conductivity_si_corr_t),  #hydraulic conductivity per stem length 
         plc_new = as.numeric(plc),
         type = case_when(
           speed_class %in% c("a") ~ "kmax", #maximum conductivity point (from speed class "a")
           speed_class %in% c("b", "c","d", "e", "f", "g", "h", "i") ~ "VC", 
           TRUE ~ as.character(speed_class)
         )) %>%  
  select(tree, mpa, neg_mpa, k, kstem_length, plc_new, type) %>% 
  mutate(size = as.factor("B"), 
         plc_new = case_when(  #set bounds for PLC new from 0-100
           plc_new < 0 ~ 0, 
           plc_new > 100 ~ 100,
           TRUE ~ as.numeric(plc_new)
         )) %>% 
  drop_na(plc_new)

vc_all_2025_2 <- vc_all_2025 %>% 
  group_by(tree) %>% 
  mutate(group = case_when(
    mpa == min(mpa) ~ "a",              #if mpa is the minimum mpa for that tree, assign group "a" (kmax)
    TRUE ~ "b")) %>%      
  group_by(tree) %>% 
  mutate(mean_kstem_a = mean(kstem_length[group == 'a'], na.rm = TRUE)) %>%  # mean of the kmax values
  ungroup() %>% 
  mutate(plc_new = 100 - (100 * kstem_length / mean_kstem_a)) %>%   #calculate PLC from 
  drop_na(plc_new)

write.csv(vc_all_2025_2, file = "yuba-phys-vulnerability-curve-raw-data-2025.csv", row.names = FALSE)

vc_raw_2025 <- read.csv("yuba-phys-vulnerability-curve-raw-data-2025.csv")

```

#automate through
```{r}
library(dplyr)
library(fitplc)

# load in 2024 and 2024 cleaned hydraulics data
vulnerability_curves_2024 <- read.csv("yuba-phys-vulnerability-curve-cleaned-data-2024.csv")
vulnerability_curves_2025 <- read.csv("yuba-phys-vulnerability-curve-cleaned-data-2025.csv")

# run this for 2024 and 2025 vulnerability curve data

# list of unique tree IDs
tree_ID <- unique(vulnerability_curves_2024$tree)

# empty lists to store results
model_list <- list()
coef_list  <- list()

# loop through 
for (t in tree_ID) {

  # Subset for one tree
  stemID <- vulnerability_curves_2024 %>%
    filter(tree == t) %>%
    mutate(
      k = format(k, scientific = FALSE),
      valid_data = plc_new >= 0
    )

  # skip trees with no valid data
  if (sum(stemID$valid_data) == 0) {
    warning(paste("No valid data for tree", t))
    next
  }

  # fit plc model
  pfit <- fitplc(
    stemID %>% filter(valid_data),
    varnames = c(PLC = "plc_new", WP = "mpa"),
    nboot = 50
  )
  plot(
    pfit,
    xlim = c(0, 7),
    ylim = c(0, 1),
    main = paste("tree ID", t)
  )
  # Store model and coefficients
  model_list[[as.character(t)]] <- pfit
  coef_list[[as.character(t)]]  <- coef(pfit)
}



coef_df <- bind_rows(
  lapply(names(coef_list), function(t) {
    data.frame(
      tree = t,
      t(coef_list[[t]]),
      row.names = NULL
    )
  })
)

print(coef_df)

```


